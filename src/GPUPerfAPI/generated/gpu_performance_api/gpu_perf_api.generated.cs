// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.
//
// This file was automatically generated by GPUPerfAPI.CodeGen - DO NOT EDIT

using System;
namespace GPUPerfAPI
{
    using System.Runtime.InteropServices;
    
    using System.Runtime.CompilerServices;
    
    public static unsafe partial class GPUPerfAPI
    {
        /// <summary>
        /// @brief Structure to hold the function table of the exported GPA APIs.
        /// </summary>
        public partial struct GpaFunctionTable
        {
            /// <summary>
            /// API major version.
            /// </summary>
            public uint major_version;
            
            /// <summary>
            /// API minor version.
            /// </summary>
            public uint minor_version;
            
            /// <summary>
            /// GPA API Table.
            /// </summary>
            public GPUPerfAPI.GpaGetFuncTablePtrType _GpaGetFuncTable;
            
            /// <summary>
            /// @brief Gets the GPA API function table.
            /// </summary>
            /// <param name="gpa_func_table">pointer to GPA Function table structure.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_api_table
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorLibLoadMajorVersionMismatch If the major version of the loaded binary does not match the header's.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorLibLoadMinorVersionMismatch If the minor version of the loaded binary does not match the header's.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetFuncTable(ref GPUPerfAPI.GpaFunctionTable gpa_func_table)
            {
                fixed (GPUPerfAPI.GpaFunctionTable* gpa_func_table_ptr = &gpa_func_table)
                return _GpaGetFuncTable.Value(gpa_func_table_ptr);
            }
            
            /// <summary>
            /// Logging.
            /// </summary>
            public GPUPerfAPI.GpaRegisterLoggingCallbackPtrType _GpaRegisterLoggingCallback;
            
            /// <summary>
            /// @brief Registers a callback function to receive log messages.
            /// </summary>
            /// <param name="logging_type">Identifies the type of messages to receive callbacks for.</param>
            /// <param name="callback_func_ptr">Pointer to the callback function.</param>
            /// <remarks>
            /// Only one callback function can be registered, so the implementation should be able
            /// to handle the different types of messages. A parameter to the callback function will
            /// indicate the message type being received. Messages will not contain a newline character
            /// at the end of the message. gpa_logging
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk On Success.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If callback_func_ptr is nullptr and the logging_type is not kGpaLoggingNone.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaRegisterLoggingCallback(GPUPerfAPI.GpaLoggingType logging_type, GPUPerfAPI.GpaLoggingCallbackPtrType callback_func_ptr)
            {
                return _GpaRegisterLoggingCallback.Value(logging_type, callback_func_ptr);
            }
            
            /// <summary>
            /// Init / Destroy GPA.
            /// </summary>
            public GPUPerfAPI.GpaInitializePtrType _GpaInitialize;
            
            /// <summary>
            /// @brief Initializes the driver so that counters are exposed.
            /// </summary>
            /// <param name="gpa_initialize_flags">Flags used to initialize GPA. This should be a combination of GpaInitializeBits.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function must be called before the rendering context or device is created. In the case of DirectX 12
            /// or Vulkan, this function must be called before a queue is created. gpa_init_destroy
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorGpaAlreadyInitialized If GPA is already initialized.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter If invalid flags have been supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaInitialize(GPUPerfAPI.GpaInitializeFlags gpa_initialize_flags)
            {
                return _GpaInitialize.Value(gpa_initialize_flags);
            }
            
            /// <summary>
            /// Init / Destroy GPA.
            /// </summary>
            public GPUPerfAPI.GpaDestroyPtrType _GpaDestroy;
            
            /// <summary>
            /// @brief Undoes any initialization to ensure proper behavior in applications that are not being profiled.
            /// </summary>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function must be called after the rendering context or device is released / destroyed. gpa_init_destroy
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorGpaNotInitialized If GPA has not been initialized.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaDestroy()
            {
                return _GpaDestroy.Value();
            }
            
            /// <summary>
            /// Context Startup / Finish.
            /// </summary>
            public GPUPerfAPI.GpaOpenContextPtrType _GpaOpenContext;
            
            /// <summary>
            /// @brief Opens the specified context, which provides access to GPU performance counters.
            /// </summary>
            /// <param name="api_context">The context to open counters for. Typically a device pointer. Refer to GPA API documentation for further details.</param>
            /// <param name="gpa_open_context_flags">Flags used to initialize the context. This should be a combination of GpaOpenContextBits.</param>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function must be called after GpaInitialize and before any other GPA functions. gpa_context_start_finish
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If either of the context parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextAlreadyOpen If the context has already been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter If one the flags is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorHardwareNotSupported If the hardware is not supported.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaOpenContext(void* api_context, GPUPerfAPI.GpaOpenContextFlags gpa_open_context_flags, out GPUPerfAPI.GpaContextId gpa_context_id)
            {
                fixed (GPUPerfAPI.GpaContextId* gpa_context_id_ptr = &gpa_context_id)
                return _GpaOpenContext.Value(api_context, gpa_open_context_flags, gpa_context_id_ptr);
            }
            
            /// <summary>
            /// Context Startup / Finish.
            /// </summary>
            public GPUPerfAPI.GpaCloseContextPtrType _GpaCloseContext;
            
            /// <summary>
            /// @brief Closes the specified context, which ends access to GPU performance counters.
            /// </summary>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// GPA functions should not be called again until the counters are reopened with GpaOpenContext. gpa_context_start_finish
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter The supplied context has invalid state.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaCloseContext(GPUPerfAPI.GpaContextId gpa_context_id)
            {
                return _GpaCloseContext.Value(gpa_context_id);
            }
            
            /// <summary>
            /// Context Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetSupportedSampleTypesPtrType _GpaGetSupportedSampleTypes;
            
            /// <summary>
            /// @brief Gets a mask of the sample types supported by the specified context.
            /// </summary>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <param name="sample_types">The value that will be set to the mask of the supported sample types upon successful execution. This will be a combination of GpaContextSampleTypeBits.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// A call to GpaCreateSession will fail if the requested sample types are not compatible with the context's sample types.
            /// supported by the context. gpa_context_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetSupportedSampleTypes(GPUPerfAPI.GpaContextId gpa_context_id, out GPUPerfAPI.GpaContextSampleTypeFlags sample_types)
            {
                fixed (GPUPerfAPI.GpaContextSampleTypeFlags* sample_types_ptr = &sample_types)
                return _GpaGetSupportedSampleTypes.Value(gpa_context_id, sample_types_ptr);
            }
            
            /// <summary>
            /// Context Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetDeviceAndRevisionIdPtrType _GpaGetDeviceAndRevisionId;
            
            /// <summary>
            /// @brief Gets the GPU device id and revision id associated with the specified context.
            /// </summary>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <param name="device_id">The value that will be set to the device id upon successful execution.</param>
            /// <param name="revision_id">The value that will be set to the device revision id upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_context_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetDeviceAndRevisionId(GPUPerfAPI.GpaContextId gpa_context_id, out uint device_id, out uint revision_id)
            {
                fixed (uint* device_id_ptr = &device_id)
                fixed (uint* revision_id_ptr = &revision_id)
                return _GpaGetDeviceAndRevisionId.Value(gpa_context_id, device_id_ptr, revision_id_ptr);
            }
            
            /// <summary>
            /// Context Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetDeviceNamePtrType _GpaGetDeviceName;
            
            /// <summary>
            /// @brief Gets the device name of the GPU associated with the specified context.
            /// </summary>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <param name="device_name">The value that will be set to the device name upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_context_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetDeviceName(GPUPerfAPI.GpaContextId gpa_context_id, out byte* device_name)
            {
                fixed (byte** device_name_ptr = &device_name)
                return _GpaGetDeviceName.Value(gpa_context_id, device_name_ptr);
            }
            
            /// <summary>
            /// Context Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaUpdateDeviceInformationPtrType _GpaUpdateDeviceInformation;
            
            /// <summary>
            /// @brief Overrides the device information for the specified context.
            /// </summary>
            /// <param name="context_id">Unique identifier of the opened context.</param>
            /// <param name="num_shader_engines">The number of shader engines.</param>
            /// <param name="num_compute_units">The total number of compute units.</param>
            /// <param name="num_simds">The total number of SIMDS.</param>
            /// <param name="num_waves_per_simd">The number of waves per SIMD.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            public unsafe GPUPerfAPI.GpaStatus GpaUpdateDeviceInformation(GPUPerfAPI.GpaContextId context_id, uint num_shader_engines, uint num_compute_units, uint num_simds, uint num_waves_per_simd)
            {
                return _GpaUpdateDeviceInformation.Value(context_id, num_shader_engines, num_compute_units, num_simds, num_waves_per_simd);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetNumCountersPtrType _GpaGetNumCounters;
            
            /// <summary>
            /// @brief Gets the number of counters available.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="number_of_counters">The value which will hold the count upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetNumCounters(GPUPerfAPI.GpaSessionId gpa_session_id, out uint number_of_counters)
            {
                fixed (uint* number_of_counters_ptr = &number_of_counters)
                return _GpaGetNumCounters.Value(gpa_session_id, number_of_counters_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterNamePtrType _GpaGetCounterName;
            
            /// <summary>
            /// @brief Gets the name of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose name is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_name">The address which will hold the name upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterName(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_name)
            {
                fixed (byte** counter_name_ptr = &counter_name)
                return _GpaGetCounterName.Value(gpa_session_id, index, counter_name_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterIndexPtrType _GpaGetCounterIndex;
            
            /// <summary>
            /// @brief Gets index of a counter given its name (case insensitive).
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="counter_name">The name of the counter whose index is needed.</param>
            /// <param name="counter_index">The address which will hold the index upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCounterNotFound If the supplied counter name cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterIndex(GPUPerfAPI.GpaSessionId gpa_session_id, string counter_name, out uint counter_index)
            {
                System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn counter_name_marshal = new();
                Span<byte> counter_name_buffer = stackalloc byte[System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn.BufferSize];
                try
                {
                    counter_name_marshal.FromManaged(counter_name, counter_name_buffer);
                    fixed (uint* counter_index_ptr = &counter_index)
                    return _GpaGetCounterIndex.Value(gpa_session_id, counter_name_marshal.ToUnmanaged(), counter_index_ptr);
                }
                finally
                {
                    counter_name_marshal.Free();
                }
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterGroupPtrType _GpaGetCounterGroup;
            
            /// <summary>
            /// @brief Gets the group of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose group is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_group">The address which will hold the group string upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterGroup(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_group)
            {
                fixed (byte** counter_group_ptr = &counter_group)
                return _GpaGetCounterGroup.Value(gpa_session_id, index, counter_group_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterDescriptionPtrType _GpaGetCounterDescription;
            
            /// <summary>
            /// @brief Gets the description of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose description is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_description">The address which will hold the description upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterDescription(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_description)
            {
                fixed (byte** counter_description_ptr = &counter_description)
                return _GpaGetCounterDescription.Value(gpa_session_id, index, counter_description_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterDataTypePtrType _GpaGetCounterDataType;
            
            /// <summary>
            /// @brief Gets the data type of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose data type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_data_type">The value which will hold the counter data type upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterDataType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaDataType counter_data_type)
            {
                fixed (GPUPerfAPI.GpaDataType* counter_data_type_ptr = &counter_data_type)
                return _GpaGetCounterDataType.Value(gpa_session_id, index, counter_data_type_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterUsageTypePtrType _GpaGetCounterUsageType;
            
            /// <summary>
            /// @brief Gets the usage type of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose usage type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_usage_type">The value which will hold the counter usage type upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterUsageType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaUsageType counter_usage_type)
            {
                fixed (GPUPerfAPI.GpaUsageType* counter_usage_type_ptr = &counter_usage_type)
                return _GpaGetCounterUsageType.Value(gpa_session_id, index, counter_usage_type_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterUuidPtrType _GpaGetCounterUuid;
            
            /// <summary>
            /// @brief Gets the UUID of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose UUID is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_uuid">The value which will hold the counter UUID upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterUuid(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaUuid counter_uuid)
            {
                fixed (GPUPerfAPI.GpaUuid* counter_uuid_ptr = &counter_uuid)
                return _GpaGetCounterUuid.Value(gpa_session_id, index, counter_uuid_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetCounterSampleTypePtrType _GpaGetCounterSampleType;
            
            /// <summary>
            /// @brief Gets the supported sample type of the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of a session.</param>
            /// <param name="index">The index of the counter whose sample type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <param name="counter_sample_type">The value which will hold the counter's supported sample type upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Currently, only a single counter type (discrete) is supported. gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetCounterSampleType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaCounterSampleType counter_sample_type)
            {
                fixed (GPUPerfAPI.GpaCounterSampleType* counter_sample_type_ptr = &counter_sample_type)
                return _GpaGetCounterSampleType.Value(gpa_session_id, index, counter_sample_type_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetDataTypeAsStrPtrType _GpaGetDataTypeAsStr;
            
            /// <summary>
            /// @brief Gets a string representation of the specified counter data type.
            /// </summary>
            /// <param name="counter_data_type">The data type whose string representation is needed.</param>
            /// <param name="type_as_str">The address which will hold the string representation upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This could be used to display counter types along with their name or value.
            /// For example, the kGpaDataTypeUint64 counter_data_type would return "gpa_uint64". gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter An invalid data type was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetDataTypeAsStr(GPUPerfAPI.GpaDataType counter_data_type, out byte* type_as_str)
            {
                fixed (byte** type_as_str_ptr = &type_as_str)
                return _GpaGetDataTypeAsStr.Value(counter_data_type, type_as_str_ptr);
            }
            
            /// <summary>
            /// Counter Interrogation.
            /// </summary>
            public GPUPerfAPI.GpaGetUsageTypeAsStrPtrType _GpaGetUsageTypeAsStr;
            
            /// <summary>
            /// @brief Gets a string representation of the specified counter usage type.
            /// </summary>
            /// <param name="counter_usage_type">The usage type whose string representation is needed.</param>
            /// <param name="usage_type_as_str">The address which will hold the string representation upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This could be used to display counter units along with their name or value.
            /// For example, the GPA_USAGE_TYPE_PERCENTAGE counterUsageType would return "percentage". gpa_counter_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter An invalid usage type was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetUsageTypeAsStr(GPUPerfAPI.GpaUsageType counter_usage_type, out byte* usage_type_as_str)
            {
                fixed (byte** usage_type_as_str_ptr = &usage_type_as_str)
                return _GpaGetUsageTypeAsStr.Value(counter_usage_type, usage_type_as_str_ptr);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaCreateSessionPtrType _GpaCreateSession;
            
            /// <summary>
            /// @brief Creates a session on the specified context.
            /// </summary>
            /// <param name="gpa_context_id">The context on which to create the session.</param>
            /// <param name="gpa_session_sample_type">The sample type that will be created on this session.</param>
            /// <param name="gpa_session_id">The address of a GpaSessionId which will be populated with the created session Id.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// A unique session identifier will be returned which allows counters to be enabled, samples to be
            /// measured, and stores the results of the profile. The sample type for the session should be
            /// specified by the caller. The requested sample types must be supported by the supplied context.
            /// Use GpaGetSupportedSampleTypes to determine which sample types are supported by a context. gpa_session_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter An invalid sample type was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIncompatibleSampleTypes The supplied sample type is not compatible with the supplied context.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaCreateSession(GPUPerfAPI.GpaContextId gpa_context_id, GPUPerfAPI.GpaSessionSampleType gpa_session_sample_type, out GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                fixed (GPUPerfAPI.GpaSessionId* gpa_session_id_ptr = &gpa_session_id)
                return _GpaCreateSession.Value(gpa_context_id, gpa_session_sample_type, gpa_session_id_ptr);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaDeleteSessionPtrType _GpaDeleteSession;
            
            /// <summary>
            /// @brief Deletes a session object.
            /// </summary>
            /// <param name="gpa_session_id">The session id that is to be deleted.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Deletes the specified session, along with all counter results associated with the session. gpa_session_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaDeleteSession(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaDeleteSession.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaBeginSessionPtrType _GpaBeginSession;
            
            /// <summary>
            /// @brief Begins sampling with the currently enabled set of counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This must be called to begin the counter sampling process.
            /// Counters must be appropriately enabled (or disabled) before BeginSession is called.
            /// The set of enabled counters cannot be changed inside a BeginSession/EndSession sequence. gpa_session_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorOtherSessionActive A different session is already active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionAlreadyStarted This session has already started.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNoCountersEnabled No counters have been enabled on this session.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaBeginSession(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaBeginSession.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaEndSessionPtrType _GpaEndSession;
            
            /// <summary>
            /// @brief Ends sampling with the currently enabled set of counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_session_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorOtherSessionActive A different session is currently active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNotEnoughPasses There have not been enough passes to complete the counter collection on this session.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorVariableNumberOfSamplesInPasses The number of samples in each pass was inconsistent.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEndSession(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaEndSession.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaResetSessionPtrType _GpaResetSession;
            
            /// <summary>
            /// @brief Resets the session to a newly created state.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This includes disabling all counters and clearing all samples. gpa_session_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any the gpa_session_id is NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaResetSession(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaResetSession.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Session handling.
            /// </summary>
            public GPUPerfAPI.GpaAbortSessionPtrType _GpaAbortSession;
            
            /// <summary>
            /// @brief Aborts sampling with the currently enabled set of counters. Regardless of whether all passes have completed or any errors have occurred
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_handling
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaAbortSession(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaAbortSession.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Session Interrogation / Configuration
            /// </summary>
            public GPUPerfAPI.GpaSqttGetInstructionMaskPtrType _GpaSqttGetInstructionMask;
            
            /// <summary>
            /// @brief Gets the mask of instruction types to be included in the SQTT data.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sqtt_instruction_mask">The value which will hold the mask of instruction types to be included in the SQTT data.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            /// All subsequent SQTT samples will use this mask.
            /// Enabling detailed instruction information will lead to a much larger volume of SQTT data. gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttGetInstructionMask(GPUPerfAPI.GpaSessionId gpa_session_id, out GPUPerfAPI.GpaSqttInstructionFlags sqtt_instruction_mask)
            {
                fixed (GPUPerfAPI.GpaSqttInstructionFlags* sqtt_instruction_mask_ptr = &sqtt_instruction_mask)
                return _GpaSqttGetInstructionMask.Value(gpa_session_id, sqtt_instruction_mask_ptr);
            }
            
            /// <summary>
            /// Session Interrogation / Configuration
            /// </summary>
            public GPUPerfAPI.GpaSqttSetInstructionMaskPtrType _GpaSqttSetInstructionMask;
            
            /// <summary>
            /// @brief Sets the mask of instruction types to be included in the SQTT data.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sqtt_instruction_mask">The new value to set the mask to.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            /// All subsequent SQTT samples will use this mask.
            /// Enabling detailed instruction information will lead to a much larger volume of SQTT data. gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttSetInstructionMask(GPUPerfAPI.GpaSessionId gpa_session_id, GPUPerfAPI.GpaSqttInstructionFlags sqtt_instruction_mask)
            {
                return _GpaSqttSetInstructionMask.Value(gpa_session_id, sqtt_instruction_mask);
            }
            
            /// <summary>
            /// Session Interrogation / Configuration
            /// </summary>
            public GPUPerfAPI.GpaSqttGetComputeUnitIdPtrType _GpaSqttGetComputeUnitId;
            
            /// <summary>
            /// @brief Gets the id of the compute unit which should generate the instruction level data.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sqtt_compute_unit_id">The value which will hold the compute unit id.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            /// All subsequent SQTT samples will use this compute unit id. Ignored if not collecting instruction-level information. Gpasession_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttGetComputeUnitId(GPUPerfAPI.GpaSessionId gpa_session_id, out uint sqtt_compute_unit_id)
            {
                fixed (uint* sqtt_compute_unit_id_ptr = &sqtt_compute_unit_id)
                return _GpaSqttGetComputeUnitId.Value(gpa_session_id, sqtt_compute_unit_id_ptr);
            }
            
            /// <summary>
            /// Session Interrogation / Configuration
            /// </summary>
            public GPUPerfAPI.GpaSqttSetComputeUnitIdPtrType _GpaSqttSetComputeUnitId;
            
            /// <summary>
            /// @brief Sets the id of the compute unit which should generate the instruction level data.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sqtt_compute_unit_id">The new value to set the compute unit id to.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            /// All subsequent SQTT samples will use this compute unit id. Ignored if not collecting instruction-level information. gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttSetComputeUnitId(GPUPerfAPI.GpaSessionId gpa_session_id, uint sqtt_compute_unit_id)
            {
                return _GpaSqttSetComputeUnitId.Value(gpa_session_id, sqtt_compute_unit_id);
            }
            
            /// <summary>
            /// SQTT functions
            /// </summary>
            public GPUPerfAPI.GpaSqttBeginPtrType _GpaSqttBegin;
            
            /// <summary>
            /// Begin collecting Session SQTT data
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="command_list">the command list to begin collecting data</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttBegin(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list)
            {
                return _GpaSqttBegin.Value(gpa_session_id, command_list);
            }
            
            /// <summary>
            /// SQTT functions
            /// </summary>
            public GPUPerfAPI.GpaSqttEndPtrType _GpaSqttEnd;
            
            /// <summary>
            /// End collecting SQTT data
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="command_list">the command list to end collection of data</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttEnd(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list)
            {
                return _GpaSqttEnd.Value(gpa_session_id, command_list);
            }
            
            /// <summary>
            /// SQTT functions
            /// </summary>
            public GPUPerfAPI.GpaSqttGetSampleResultSizePtrType _GpaSqttGetSampleResultSize;
            
            /// <summary>
            /// Get SQTT sample result size
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_result_size_in_bytes">returns the number of bytes of data collected</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, out nuint sample_result_size_in_bytes)
            {
                fixed (nuint* sample_result_size_in_bytes_ptr = &sample_result_size_in_bytes)
                return _GpaSqttGetSampleResultSize.Value(gpa_session_id, sample_result_size_in_bytes_ptr);
            }
            
            /// <summary>
            /// SQTT functions
            /// </summary>
            public GPUPerfAPI.GpaSqttGetSampleResultPtrType _GpaSqttGetSampleResult;
            
            /// <summary>
            /// Gets the SQTT sample results
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_result_size_in_bytes">size of the sqtt_results buffer</param>
            /// <param name="sqtt_results">buffer to return results in</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSqttGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, nuint sample_result_size_in_bytes, void* sqtt_results)
            {
                return _GpaSqttGetSampleResult.Value(gpa_session_id, sample_result_size_in_bytes, sqtt_results);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmSetSampleIntervalPtrType _GpaSpmSetSampleInterval;
            
            /// <summary>
            /// [Optional] Sets the sample interval for SPM data. The default is 4096.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="interval">sampling interval in clock cycles of the GPU shader clock domain (SCLK). This ranges from [32 - 4096]</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmSetSampleInterval(GPUPerfAPI.GpaSessionId gpa_session_id, uint interval)
            {
                return _GpaSpmSetSampleInterval.Value(gpa_session_id, interval);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmSetDurationPtrType _GpaSpmSetDuration;
            
            /// <summary>
            /// [Optional] Sets the duration of the SPM sample. The default is to assume that the sample is as large as possible.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="nanosecond_duration">duration in nanoseconds</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            /// If the duration is set, this allows the driver to optimize the amount of memory that is allocated for
            /// the SPM session. If the duration is not set, the recommended maximum amount of GPU memory will be
            /// allocated for SPM collection gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmSetDuration(GPUPerfAPI.GpaSessionId gpa_session_id, uint nanosecond_duration)
            {
                return _GpaSpmSetDuration.Value(gpa_session_id, nanosecond_duration);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmBeginPtrType _GpaSpmBegin;
            
            /// <summary>
            /// Begin collecting SPM data
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="command_list">the command list to begin collecting data</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmBegin(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list)
            {
                return _GpaSpmBegin.Value(gpa_session_id, command_list);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmEndPtrType _GpaSpmEnd;
            
            /// <summary>
            /// End collecting SPM data
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="command_list">the command list to end collecting data</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmEnd(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list)
            {
                return _GpaSpmEnd.Value(gpa_session_id, command_list);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmGetSampleResultSizePtrType _GpaSpmGetSampleResultSize;
            
            /// <summary>
            /// Get SPM sample result size
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_result_size_in_bytes">returns the number of bytes of data collected.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, out nuint sample_result_size_in_bytes)
            {
                fixed (nuint* sample_result_size_in_bytes_ptr = &sample_result_size_in_bytes)
                return _GpaSpmGetSampleResultSize.Value(gpa_session_id, sample_result_size_in_bytes_ptr);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmGetSampleResultPtrType _GpaSpmGetSampleResult;
            
            /// <summary>
            /// Gets the SPM sample results
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_result_size_in_bytes">size of the spm_results buffer.</param>
            /// <param name="spm_results">buffer of returned results.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, nuint sample_result_size_in_bytes, void* spm_results)
            {
                return _GpaSpmGetSampleResult.Value(gpa_session_id, sample_result_size_in_bytes, spm_results);
            }
            
            /// <summary>
            /// SPM functions
            /// </summary>
            public GPUPerfAPI.GpaSpmCalculateDerivedCountersPtrType _GpaSpmCalculateDerivedCounters;
            
            /// <summary>
            /// Calculate derived counters from collected SPM data
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="spm_data">Collected SPM data.</param>
            /// <param name="derived_counter_count">Number of counters that were enabled.</param>
            /// <param name="derived_counter_results">Counter results of num_derived_counters * timestamps entries.</param>
            /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
            /// <remarks>
            ///  gpa_session_interrogation
            /// </remarks>
            public unsafe GPUPerfAPI.GpaStatus GpaSpmCalculateDerivedCounters(GPUPerfAPI.GpaSessionId gpa_session_id, ref GPUPerfAPI.GpaSpmData spm_data, uint derived_counter_count, ulong* derived_counter_results)
            {
                fixed (GPUPerfAPI.GpaSpmData* spm_data_ptr = &spm_data)
                return _GpaSpmCalculateDerivedCounters.Value(gpa_session_id, spm_data_ptr, derived_counter_count, derived_counter_results);
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaEnableCounterPtrType _GpaEnableCounter;
            
            /// <summary>
            /// @brief Enables the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session on which to enable the counter.</param>
            /// <param name="counter_index">The index of the counter to enable. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will provide values for any enabled counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorAlreadyEnabled The specified counter is already enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEnableCounter(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index)
            {
                return _GpaEnableCounter.Value(gpa_session_id, counter_index);
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaDisableCounterPtrType _GpaDisableCounter;
            
            /// <summary>
            /// @brief Disables the specified counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session on which to disable the counter.</param>
            /// <param name="counter_index">The index of the counter to disable. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will not provide values for any disabled counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNotEnabled The counter was not enabled, so it cannot be disabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaDisableCounter(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index)
            {
                return _GpaDisableCounter.Value(gpa_session_id, counter_index);
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaEnableCounterByNamePtrType _GpaEnableCounterByName;
            
            /// <summary>
            /// @brief Enables the counter with the specified counter name (case insensitive).
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="counter_name">The name of the counter to enable.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will provide values for any enabled counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCounterNotFound The named counter cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorAlreadyEnabled The specified counter is already enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEnableCounterByName(GPUPerfAPI.GpaSessionId gpa_session_id, string counter_name)
            {
                System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn counter_name_marshal = new();
                Span<byte> counter_name_buffer = stackalloc byte[System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn.BufferSize];
                try
                {
                    counter_name_marshal.FromManaged(counter_name, counter_name_buffer);
                    return _GpaEnableCounterByName.Value(gpa_session_id, counter_name_marshal.ToUnmanaged());
                }
                finally
                {
                    counter_name_marshal.Free();
                }
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaDisableCounterByNamePtrType _GpaDisableCounterByName;
            
            /// <summary>
            /// @brief Disables the counter with the specified counter name (case insensitive).
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="counter_name">The name of the counter to disable.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will not provide values for any disabled counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCounterNotFound The named counter cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaDisableCounterByName(GPUPerfAPI.GpaSessionId gpa_session_id, string counter_name)
            {
                System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn counter_name_marshal = new();
                Span<byte> counter_name_buffer = stackalloc byte[System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn.BufferSize];
                try
                {
                    counter_name_marshal.FromManaged(counter_name, counter_name_buffer);
                    return _GpaDisableCounterByName.Value(gpa_session_id, counter_name_marshal.ToUnmanaged());
                }
                finally
                {
                    counter_name_marshal.Free();
                }
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaEnableAllCountersPtrType _GpaEnableAllCounters;
            
            /// <summary>
            /// @brief Enables all counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will provide values for all counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEnableAllCounters(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaEnableAllCounters.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaDisableAllCountersPtrType _GpaDisableAllCounters;
            
            /// <summary>
            /// @brief Disables all counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// Subsequent sampling sessions will not provide values for any disabled counters.
            /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaDisableAllCounters(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaDisableAllCounters.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Query Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaGetPassCountPtrType _GpaGetPassCount;
            
            /// <summary>
            /// @brief Gets the number of passes required for the currently enabled set of counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="number_of_passes">The value which will hold the number of required passes upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This represents the number of times the same sequence must be repeated to capture the counter data.
            /// On each pass a different (compatible) set of counters will be measured. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetPassCount(GPUPerfAPI.GpaSessionId gpa_session_id, out uint number_of_passes)
            {
                fixed (uint* number_of_passes_ptr = &number_of_passes)
                return _GpaGetPassCount.Value(gpa_session_id, number_of_passes_ptr);
            }
            
            /// <summary>
            /// Query Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaGetNumEnabledCountersPtrType _GpaGetNumEnabledCounters;
            
            /// <summary>
            /// @brief Gets the number of enabled counters.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="enabled_counter_count">The value which will hold the number of enabled counters contained within the session upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetNumEnabledCounters(GPUPerfAPI.GpaSessionId gpa_session_id, out uint enabled_counter_count)
            {
                fixed (uint* enabled_counter_count_ptr = &enabled_counter_count)
                return _GpaGetNumEnabledCounters.Value(gpa_session_id, enabled_counter_count_ptr);
            }
            
            /// <summary>
            /// Query Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaGetEnabledIndexPtrType _GpaGetEnabledIndex;
            
            /// <summary>
            /// @brief Gets the counter index for an enabled counter.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="enabled_number">The number of the enabled counter to get the counter index for. Must lie between 0 and (GpaGetNumEnabledCounters result - 1).</param>
            /// <param name="enabled_counter_index">The value that will hold the index of the counter upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This is meant to be used with GpaGetNumEnabledCounters. Once you determine the number of enabled counters,
            /// you can use GpaGetEnabledIndex to determine which counters are enabled. gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange The enabled number is higher than the number of enabled counters.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetEnabledIndex(GPUPerfAPI.GpaSessionId gpa_session_id, uint enabled_number, out uint enabled_counter_index)
            {
                fixed (uint* enabled_counter_index_ptr = &enabled_counter_index)
                return _GpaGetEnabledIndex.Value(gpa_session_id, enabled_number, enabled_counter_index_ptr);
            }
            
            /// <summary>
            /// Query Counter Scheduling.
            /// </summary>
            public GPUPerfAPI.GpaIsCounterEnabledPtrType _GpaIsCounterEnabled;
            
            /// <summary>
            /// @brief Checks whether or not a counter is enabled.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the session.</param>
            /// <param name="counter_index">The index of the counter. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
            /// <remarks>
            ///  gpa_counter_scheduling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk is returned if the counter is enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCounterNotFound is returned if it is not enabled.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaIsCounterEnabled(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index)
            {
                return _GpaIsCounterEnabled.Value(gpa_session_id, counter_index);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaBeginCommandListPtrType _GpaBeginCommandList;
            
            /// <summary>
            /// @brief Begins command list for sampling.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="pass_index">0-based index of the pass.</param>
            /// <param name="command_list">The command list on which to begin sampling - ignored in OpenGL/DX11 applications.</param>
            /// <param name="command_list_type">Command list type.</param>
            /// <param name="gpa_command_list_id">GPA-generated unique command list id.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// You will be unable to create samples on the specified command list before GpaBeginCommandList is called.
            /// Command list corresponds to ID3D12GraphicsCommandList in DirectX 12 and vkCommandBuffer in Vulkan.
            /// In OpenGL/DirectX 11, use GPA_NULL_COMMAND_LIST for the command_list parameter and kGpaCommandListNone for the command_list_type parameter. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If the command list is required, it must not be NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorInvalidParameter The command list type is invalid, or the command list must be null and the type must be kGpaCommandListNone.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListAlreadyStarted The supplied command list has already been started, and cannot be started again.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaBeginCommandList(GPUPerfAPI.GpaSessionId gpa_session_id, uint pass_index, void* command_list, GPUPerfAPI.GpaCommandListType command_list_type, out GPUPerfAPI.GpaCommandListId gpa_command_list_id)
            {
                fixed (GPUPerfAPI.GpaCommandListId* gpa_command_list_id_ptr = &gpa_command_list_id)
                return _GpaBeginCommandList.Value(gpa_session_id, pass_index, command_list, command_list_type, gpa_command_list_id_ptr);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaEndCommandListPtrType _GpaEndCommandList;
            
            /// <summary>
            /// @brief Ends command list for sampling.
            /// </summary>
            /// <param name="gpa_command_list_id">The command list on which to end sampling - ignored in OpenGL applications.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// You will be unable to create samples on the specified command list after GpaEndCommandList is called. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEndCommandList(GPUPerfAPI.GpaCommandListId gpa_command_list_id)
            {
                return _GpaEndCommandList.Value(gpa_command_list_id);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaBeginSamplePtrType _GpaBeginSample;
            
            /// <summary>
            /// @brief Begins a sample in a command list.
            /// </summary>
            /// <param name="sample_id">Unique sample id.</param>
            /// <param name="gpa_command_list_id">Unique identifier of a previously-created GPA Command List Object.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// A sample is a particular workload for which counters will be collected.
            /// If the owning session was created with kGpaSessionSampleTypeDiscreteCounter and
            /// one or more counters have been enabled, then those counters will be collected for this sample.
            /// Each sample must be associated with a GPA command list.
            /// Samples can be created by multiple threads provided no two threads are creating samples on same command list.
            /// You must provide a unique Id for every new sample. When performing multiple passes, a sample must exist in all passes.
            /// You may create as many samples as needed. However, nesting of samples is not allowed.
            /// Each sample must be wrapped in sequence of GpaBeginSample/GpaEndSample before starting another one.
            /// A sample can be started in one primary command list and continued/ended on another primary command list - See GpaContinueSampleOnCommandList. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange The sample has been started in too many passes.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaBeginSample(uint sample_id, GPUPerfAPI.GpaCommandListId gpa_command_list_id)
            {
                return _GpaBeginSample.Value(sample_id, gpa_command_list_id);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaEndSamplePtrType _GpaEndSample;
            
            /// <summary>
            /// @brief Ends a sample in a command list.
            /// </summary>
            /// <param name="gpa_command_list_id">Command list id on which the sample is ending - the command list may be different than the command list on which the sample was started.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// A sample is a particular workload for which counters will be collected.
            /// If the owning session was created with kGpaSessionSampleTypeDiscreteCounter and
            /// one or more counters have been enabled, then those counters will be collected for this sample.
            /// Each sample must be associated with a GPA command list.
            /// Samples can be created by using multiple threads provided no two threads are creating samples on same command list.
            /// You must provide a unique Id for every new sample.
            /// You may create as many samples as needed. However, nesting of samples is not allowed.
            /// Each sample must be wrapped in sequence of GpaBeginSample/GpaEndSample before starting another one.
            /// A sample can be started in one primary command list and continued/ended on another primary command list - See GpaContinueSampleOnCommandList. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorIndexOutOfRange The sample has been ended in too many passes.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaEndSample(GPUPerfAPI.GpaCommandListId gpa_command_list_id)
            {
                return _GpaEndSample.Value(gpa_command_list_id);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaContinueSampleOnCommandListPtrType _GpaContinueSampleOnCommandList;
            
            /// <summary>
            /// @brief Continues a primary command list sample on another primary command list.
            /// </summary>
            /// <param name="source_sample_id">The sample id of the sample being continued on a different command list.</param>
            /// <param name="primary_gpa_command_list_id">Primary command list id on which the sample is continuing.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function is only supported for DirectX 12 and Vulkan.
            /// Samples can be started on one primary command list and continued/ended on another primary command list. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorApiNotSupported This entrypoint is being called in a graphics API that does not support it.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer The supplied command list id is NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListNotFound The supplied command list id cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSampleNotFound The source sample id cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaContinueSampleOnCommandList(uint source_sample_id, GPUPerfAPI.GpaCommandListId primary_gpa_command_list_id)
            {
                return _GpaContinueSampleOnCommandList.Value(source_sample_id, primary_gpa_command_list_id);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaCopySecondarySamplesPtrType _GpaCopySecondarySamples;
            
            /// <summary>
            /// @brief Copies a set of samples from a secondary command list back to the primary command list that executed the secondary command list.
            /// </summary>
            /// <param name="secondary_gpa_command_list_id">Secondary command list where the secondary samples were created.</param>
            /// <param name="primary_gpa_command_list_id">Primary command list to which the samples results should be copied. This should be the command list that executed the secondary command list.</param>
            /// <param name="number_of_samples">Number of secondary samples.</param>
            /// <param name="new_sample_ids">New sample ids on a primary command list.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function is only supported for DirectX 12 and Vulkan.
            /// GPA doesn't collect data for the samples created on secondary command lists unless they are copied to a new set of samples for the primary command list. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorApiNotSupported This entrypoint is being called in a graphics API that does not support it.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer One of the supplied command list IDs is NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorCommandListNotFound One of the supplied command list IDs cannot be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaCopySecondarySamples(GPUPerfAPI.GpaCommandListId secondary_gpa_command_list_id, GPUPerfAPI.GpaCommandListId primary_gpa_command_list_id, uint number_of_samples, uint* new_sample_ids)
            {
                return _GpaCopySecondarySamples.Value(secondary_gpa_command_list_id, primary_gpa_command_list_id, number_of_samples, new_sample_ids);
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaGetSampleCountPtrType _GpaGetSampleCount;
            
            /// <summary>
            /// @brief Gets the number of samples created for the specified session.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_count">The value which will hold the number of samples contained within the session upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This is useful if samples are conditionally created and a count is not kept. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer One of the parameters is NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetSampleCount(GPUPerfAPI.GpaSessionId gpa_session_id, out uint sample_count)
            {
                fixed (uint* sample_count_ptr = &sample_count)
                return _GpaGetSampleCount.Value(gpa_session_id, sample_count_ptr);
            }
            
            /// <summary>
            /// Query Results.
            /// </summary>
            public GPUPerfAPI.GpaIsPassCompletePtrType _GpaIsPassComplete;
            
            /// <summary>
            /// @brief Checks whether or not a pass has finished.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="pass_index">0-based index of the pass.</param>
            /// <remarks>
            /// After sampling a workload, results may be available immediately or take a certain amount of time to become available.
            /// This function allows you to determine when the pass has finished and associated resources are no longer needed in the application.
            /// The function does not block, permitting periodic polling.
            /// The application must not free its resources until this function returns kGpaStatusOk. gpa_query_results
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the pass is complete.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusResultNotReady If the result is not yet ready.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaIsPassComplete(GPUPerfAPI.GpaSessionId gpa_session_id, uint pass_index)
            {
                return _GpaIsPassComplete.Value(gpa_session_id, pass_index);
            }
            
            /// <summary>
            /// Query Results.
            /// </summary>
            public GPUPerfAPI.GpaIsSessionCompletePtrType _GpaIsSessionComplete;
            
            /// <summary>
            /// @brief Checks if results for all samples within a session are available.
            /// </summary>
            /// <param name="gpa_session_id">The value that will be set to the session identifier.</param>
            /// <remarks>
            /// After a sampling session results may be available immediately or take a certain amount of time to become available.
            /// This function allows you to determine when the results of a session can be read.
            /// The function does not block, permitting periodic polling.
            /// To block until a sample is ready use GpaGetSampleResult instead. gpa_query_results
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the session is complete.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusResultNotReady If the result is not yet ready.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotStarted If the supplied session has not been started.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaIsSessionComplete(GPUPerfAPI.GpaSessionId gpa_session_id)
            {
                return _GpaIsSessionComplete.Value(gpa_session_id);
            }
            
            /// <summary>
            /// Query Results.
            /// </summary>
            public GPUPerfAPI.GpaGetSampleResultSizePtrType _GpaGetSampleResultSize;
            
            /// <summary>
            /// @brief Gets the result size (in bytes) for a given sample.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="sample_id">The identifier of the sample to get the result size for.</param>
            /// <param name="sample_result_size_in_bytes">The value that will be set to the result size upon successful execution  - this value needs to be passed to GetSampleResult.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// For discrete counter samples, the size will be the same for all samples, so it would be valid to retrieve the
            /// result size for one sample and use that when retrieving results for all samples. gpa_query_results
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSampleNotFound The supplied sample id could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, uint sample_id, out nuint sample_result_size_in_bytes)
            {
                fixed (nuint* sample_result_size_in_bytes_ptr = &sample_result_size_in_bytes)
                return _GpaGetSampleResultSize.Value(gpa_session_id, sample_id, sample_result_size_in_bytes_ptr);
            }
            
            /// <summary>
            /// Query Results.
            /// </summary>
            public GPUPerfAPI.GpaGetSampleResultPtrType _GpaGetSampleResult;
            
            /// <summary>
            /// @brief Gets the result data for a given sample.
            /// </summary>
            /// <param name="gpa_session_id">The session identifier with the sample you wish to retrieve the result of.</param>
            /// <param name="sample_id">The identifier of the sample to get the result for.</param>
            /// <param name="sample_result_size_in_bytes">Size of sample in bytes.</param>
            /// <param name="counter_sample_results">Address to which the counter data for the sample will be copied to.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This function will block until results are ready. Use GpaIsSessionComplete to check if results are ready. gpa_query_results
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer An invalid or NULL parameter was supplied.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSampleNotFound The supplied sample id could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorReadingSampleResult The supplied buffer is too small for the sample results.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, uint sample_id, nuint sample_result_size_in_bytes, void* counter_sample_results)
            {
                return _GpaGetSampleResult.Value(gpa_session_id, sample_id, sample_result_size_in_bytes, counter_sample_results);
            }
            
            /// <summary>
            /// Status / Error Query.
            /// </summary>
            public GPUPerfAPI.GpaGetStatusAsStrPtrType _GpaGetStatusAsStr;
            
            /// <summary>
            /// @brief Gets a string representation of the specified GPA status value.
            /// </summary>
            /// <param name="status">The status whose string representation is needed.</param>
            /// <returns>@return A string which briefly describes the specified status.</returns>
            /// <remarks>
            /// Provides a simple method to convert a status enum value into a string which can be used to display log messages. gpa_status_query
            /// </remarks>
            public unsafe string GpaGetStatusAsStr(GPUPerfAPI.GpaStatus status)
            {
                return System.Runtime.InteropServices.Marshal.PtrToStringUTF8((nint)_GpaGetStatusAsStr.Value(status));
            }
            
            /// <summary>
            /// Sample Handling.
            /// </summary>
            public GPUPerfAPI.GpaGetSampleIdPtrType _GpaGetSampleId;
            
            /// <summary>
            /// @brief Gets the sample id by index.
            /// </summary>
            /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
            /// <param name="index">The index of the sample. Must lie between 0 and (GpaGetSampleCount result - 1).</param>
            /// <param name="sample_id">The value that will hold the id of the sample upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            /// This is useful if sample ids are either not zero-based or not consecutive. gpa_sample_handling
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer One of the parameters is NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorSampleNotFound The supplied index is greater than the number of samples.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetSampleId(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out uint sample_id)
            {
                fixed (uint* sample_id_ptr = &sample_id)
                return _GpaGetSampleId.Value(gpa_session_id, index, sample_id_ptr);
            }
            
            /// <summary>
            /// GPA API Version.
            /// </summary>
            public GPUPerfAPI.GpaGetVersionPtrType _GpaGetVersion;
            
            /// <summary>
            /// @brief Gets the GPA version.
            /// </summary>
            /// <param name="major_version">The value that will hold the major version of GPA upon successful execution.</param>
            /// <param name="minor_version">The value that will hold the minor version of GPA upon successful execution.</param>
            /// <param name="build_version">The value that will hold the build number of GPA upon successful execution.</param>
            /// <param name="update_version">The value that will hold the update version of GPA upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_api_version
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetVersion(out uint major_version, out uint minor_version, out uint build_version, out uint update_version)
            {
                fixed (uint* major_version_ptr = &major_version)
                fixed (uint* minor_version_ptr = &minor_version)
                fixed (uint* build_version_ptr = &build_version)
                fixed (uint* update_version_ptr = &update_version)
                return _GpaGetVersion.Value(major_version_ptr, minor_version_ptr, build_version_ptr, update_version_ptr);
            }
            
            /// <summary>
            /// Context interrogation; added in 3.10
            /// </summary>
            public GPUPerfAPI.GpaGetDeviceGenerationPtrType _GpaGetDeviceGeneration;
            
            /// <summary>
            /// @brief Gets the GPU hardware generation associated with the specified context.
            /// </summary>
            /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
            /// <param name="hardware_generation">The value that will be set to the hardware generation upon successful execution.</param>
            /// <returns>@return The GPA result status of the operation.</returns>
            /// <remarks>
            ///  gpa_context_interrogation
            /// </remarks>
            /// <retval>
            /// @retval kGpaStatusOk If the operation is successful.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorFailed If an internal error has occurred.
            /// </retval>
            /// <retval>
            /// @retval kGpaStatusErrorException If an unexpected error has occurred.
            /// </retval>
            public unsafe GPUPerfAPI.GpaStatus GpaGetDeviceGeneration(GPUPerfAPI.GpaContextId gpa_context_id, out GPUPerfAPI.GpaHwGeneration hardware_generation)
            {
                fixed (GPUPerfAPI.GpaHwGeneration* hardware_generation_ptr = &hardware_generation)
                return _GpaGetDeviceGeneration.Value(gpa_context_id, hardware_generation_ptr);
            }
        }
        
        public const int GPA_FUNCTION_TABLE_MAJOR_VERSION_NUMBER = 4;
        
        public const int GPA_FUNCTION_TABLE_MINOR_VERSION_NUMBER = 544;
        
        /// <summary>
        /// @brief Gets the GPA version.
        /// </summary>
        /// <param name="major_version">The value that will hold the major version of GPA upon successful execution.</param>
        /// <param name="minor_version">The value that will hold the minor version of GPA upon successful execution.</param>
        /// <param name="build_version">The value that will hold the build number of GPA upon successful execution.</param>
        /// <param name="update_version">The value that will hold the update version of GPA upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_api_version
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetVersion")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetVersion(out uint major_version, out uint minor_version, out uint build_version, out uint update_version);
        
        /// <summary>
        /// @brief Gets the GPA API function table.
        /// </summary>
        /// <param name="gpa_func_table">pointer to GPA Function table structure.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_api_table
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorLibLoadMajorVersionMismatch If the major version of the loaded binary does not match the header's.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorLibLoadMinorVersionMismatch If the minor version of the loaded binary does not match the header's.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetFuncTable")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetFuncTable(ref GPUPerfAPI.GpaFunctionTable gpa_func_table);
        
        /// <summary>
        /// @brief Registers a callback function to receive log messages.
        /// </summary>
        /// <param name="logging_type">Identifies the type of messages to receive callbacks for.</param>
        /// <param name="callback_func_ptr">Pointer to the callback function.</param>
        /// <remarks>
        /// Only one callback function can be registered, so the implementation should be able
        /// to handle the different types of messages. A parameter to the callback function will
        /// indicate the message type being received. Messages will not contain a newline character
        /// at the end of the message. gpa_logging
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk On Success.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If callback_func_ptr is nullptr and the logging_type is not kGpaLoggingNone.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaRegisterLoggingCallback")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaRegisterLoggingCallback(GPUPerfAPI.GpaLoggingType logging_type, GPUPerfAPI.GpaLoggingCallbackPtrType callback_func_ptr);
        
        /// <summary>
        /// @brief Initializes the driver so that counters are exposed.
        /// </summary>
        /// <param name="gpa_initialize_flags">Flags used to initialize GPA. This should be a combination of GpaInitializeBits.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function must be called before the rendering context or device is created. In the case of DirectX 12
        /// or Vulkan, this function must be called before a queue is created. gpa_init_destroy
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorGpaAlreadyInitialized If GPA is already initialized.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter If invalid flags have been supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaInitialize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaInitialize(GPUPerfAPI.GpaInitializeFlags gpa_initialize_flags);
        
        /// <summary>
        /// @brief Undoes any initialization to ensure proper behavior in applications that are not being profiled.
        /// </summary>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function must be called after the rendering context or device is released / destroyed. gpa_init_destroy
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorGpaNotInitialized If GPA has not been initialized.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaDestroy")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaDestroy();
        
        /// <summary>
        /// @brief Opens the specified context, which provides access to GPU performance counters.
        /// </summary>
        /// <param name="api_context">The context to open counters for. Typically a device pointer. Refer to GPA API documentation for further details.</param>
        /// <param name="gpa_open_context_flags">Flags used to initialize the context. This should be a combination of GpaOpenContextBits.</param>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function must be called after GpaInitialize and before any other GPA functions. gpa_context_start_finish
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If either of the context parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextAlreadyOpen If the context has already been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter If one the flags is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorHardwareNotSupported If the hardware is not supported.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaOpenContext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaOpenContext(void* api_context, GPUPerfAPI.GpaOpenContextFlags gpa_open_context_flags, out GPUPerfAPI.GpaContextId gpa_context_id);
        
        /// <summary>
        /// @brief Closes the specified context, which ends access to GPU performance counters.
        /// </summary>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// GPA functions should not be called again until the counters are reopened with GpaOpenContext. gpa_context_start_finish
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter The supplied context has invalid state.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaCloseContext")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaCloseContext(GPUPerfAPI.GpaContextId gpa_context_id);
        
        /// <summary>
        /// @brief Gets a mask of the sample types supported by the specified context.
        /// </summary>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <param name="sample_types">The value that will be set to the mask of the supported sample types upon successful execution. This will be a combination of GpaContextSampleTypeBits.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// A call to GpaCreateSession will fail if the requested sample types are not compatible with the context's sample types.
        /// supported by the context. gpa_context_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetSupportedSampleTypes")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetSupportedSampleTypes(GPUPerfAPI.GpaContextId gpa_context_id, out GPUPerfAPI.GpaContextSampleTypeFlags sample_types);
        
        /// <summary>
        /// @brief Gets the GPU device id and revision id associated with the specified context.
        /// </summary>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <param name="device_id">The value that will be set to the device id upon successful execution.</param>
        /// <param name="revision_id">The value that will be set to the device revision id upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_context_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetDeviceAndRevisionId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetDeviceAndRevisionId(GPUPerfAPI.GpaContextId gpa_context_id, out uint device_id, out uint revision_id);
        
        /// <summary>
        /// @brief Overrides the device information for the specified context.
        /// </summary>
        /// <param name="context_id">Unique identifier of the opened context.</param>
        /// <param name="num_shader_engines">The number of shader engines.</param>
        /// <param name="num_compute_units">The total number of compute units.</param>
        /// <param name="num_simds">The total number of SIMDS.</param>
        /// <param name="num_waves_per_simd">The number of waves per SIMD.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaUpdateDeviceInformation")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaUpdateDeviceInformation(GPUPerfAPI.GpaContextId context_id, uint num_shader_engines, uint num_compute_units, uint num_simds, uint num_waves_per_simd);
        
        /// <summary>
        /// @brief Gets the device name of the GPU associated with the specified context.
        /// </summary>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <param name="device_name">The value that will be set to the device name upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_context_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetDeviceName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetDeviceName(GPUPerfAPI.GpaContextId gpa_context_id, out byte* device_name);
        
        /// <summary>
        /// @brief Gets the GPU hardware generation associated with the specified context.
        /// </summary>
        /// <param name="gpa_context_id">Unique identifier of the opened context.</param>
        /// <param name="hardware_generation">The value that will be set to the hardware generation upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_context_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetDeviceGeneration")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetDeviceGeneration(GPUPerfAPI.GpaContextId gpa_context_id, out GPUPerfAPI.GpaHwGeneration hardware_generation);
        
        /// <summary>
        /// @brief Gets the number of counters available.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="number_of_counters">The value which will hold the count upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetNumCounters")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetNumCounters(GPUPerfAPI.GpaSessionId gpa_session_id, out uint number_of_counters);
        
        /// <summary>
        /// @brief Gets the name of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose name is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_name">The address which will hold the name upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterName(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_name);
        
        /// <summary>
        /// @brief Gets index of a counter given its name (case insensitive).
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="counter_name">The name of the counter whose index is needed.</param>
        /// <param name="counter_index">The address which will hold the index upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCounterNotFound If the supplied counter name cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterIndex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterIndex(GPUPerfAPI.GpaSessionId gpa_session_id, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPUTF8Str)] string counter_name, out uint counter_index);
        
        /// <summary>
        /// @brief Gets the group of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose group is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_group">The address which will hold the group string upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterGroup")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterGroup(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_group);
        
        /// <summary>
        /// @brief Gets the description of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose description is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_description">The address which will hold the description upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterDescription")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterDescription(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out byte* counter_description);
        
        /// <summary>
        /// @brief Gets the data type of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose data type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_data_type">The value which will hold the counter data type upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterDataType")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterDataType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaDataType counter_data_type);
        
        /// <summary>
        /// @brief Gets the usage type of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose usage type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_usage_type">The value which will hold the counter usage type upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterUsageType")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterUsageType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaUsageType counter_usage_type);
        
        /// <summary>
        /// @brief Gets the UUID of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose UUID is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_uuid">The value which will hold the counter UUID upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterUuid")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterUuid(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaUuid counter_uuid);
        
        /// <summary>
        /// @brief Gets the supported sample type of the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of a session.</param>
        /// <param name="index">The index of the counter whose sample type is needed. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <param name="counter_sample_type">The value which will hold the counter's supported sample type upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Currently, only a single counter type (discrete) is supported. gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound If the supplied session is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetCounterSampleType")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetCounterSampleType(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out GPUPerfAPI.GpaCounterSampleType counter_sample_type);
        
        /// <summary>
        /// @brief Gets a string representation of the specified counter data type.
        /// </summary>
        /// <param name="counter_data_type">The data type whose string representation is needed.</param>
        /// <param name="type_as_str">The address which will hold the string representation upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This could be used to display counter types along with their name or value.
        /// For example, the kGpaDataTypeUint64 counter_data_type would return "gpa_uint64". gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter An invalid data type was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetDataTypeAsStr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetDataTypeAsStr(GPUPerfAPI.GpaDataType counter_data_type, out byte* type_as_str);
        
        /// <summary>
        /// @brief Gets a string representation of the specified counter usage type.
        /// </summary>
        /// <param name="counter_usage_type">The usage type whose string representation is needed.</param>
        /// <param name="usage_type_as_str">The address which will hold the string representation upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This could be used to display counter units along with their name or value.
        /// For example, the GPA_USAGE_TYPE_PERCENTAGE counterUsageType would return "percentage". gpa_counter_interrogation
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter An invalid usage type was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetUsageTypeAsStr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetUsageTypeAsStr(GPUPerfAPI.GpaUsageType counter_usage_type, out byte* usage_type_as_str);
        
        /// <summary>
        /// @brief Creates a session on the specified context.
        /// </summary>
        /// <param name="gpa_context_id">The context on which to create the session.</param>
        /// <param name="gpa_session_sample_type">The sample type that will be created on this session.</param>
        /// <param name="gpa_session_id">The address of a GpaSessionId which will be populated with the created session Id.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// A unique session identifier will be returned which allows counters to be enabled, samples to be
        /// measured, and stores the results of the profile. The sample type for the session should be
        /// specified by the caller. The requested sample types must be supported by the supplied context.
        /// Use GpaGetSupportedSampleTypes to determine which sample types are supported by a context. gpa_session_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotFound If the supplied context is invalid.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen If the supplied context has not been opened.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter An invalid sample type was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIncompatibleSampleTypes The supplied sample type is not compatible with the supplied context.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaCreateSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaCreateSession(GPUPerfAPI.GpaContextId gpa_context_id, GPUPerfAPI.GpaSessionSampleType gpa_session_sample_type, out GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Deletes a session object.
        /// </summary>
        /// <param name="gpa_session_id">The session id that is to be deleted.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Deletes the specified session, along with all counter results associated with the session. gpa_session_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaDeleteSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaDeleteSession(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Begins sampling with the currently enabled set of counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This must be called to begin the counter sampling process.
        /// Counters must be appropriately enabled (or disabled) before BeginSession is called.
        /// The set of enabled counters cannot be changed inside a BeginSession/EndSession sequence. gpa_session_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorOtherSessionActive A different session is already active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionAlreadyStarted This session has already started.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNoCountersEnabled No counters have been enabled on this session.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaBeginSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaBeginSession(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Resets the session to a newly created state.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This includes disabling all counters and clearing all samples. gpa_session_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any the gpa_session_id is NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaResetSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaResetSession(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Aborts sampling with the currently enabled set of counters. Regardless of whether all passes have completed or any errors have occurred
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_handling
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaAbortSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaAbortSession(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Gets the mask of instruction types to be included in the SQTT data.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sqtt_instruction_mask">The value which will hold the mask of instruction types to be included in the SQTT data.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        /// All subsequent SQTT samples will use this mask.
        /// Enabling detailed instruction information will lead to a much larger volume of SQTT data. gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttGetInstructionMask")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttGetInstructionMask(GPUPerfAPI.GpaSessionId gpa_session_id, out GPUPerfAPI.GpaSqttInstructionFlags sqtt_instruction_mask);
        
        /// <summary>
        /// @brief Sets the mask of instruction types to be included in the SQTT data.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sqtt_instruction_mask">The new value to set the mask to.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        /// All subsequent SQTT samples will use this mask.
        /// Enabling detailed instruction information will lead to a much larger volume of SQTT data. gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttSetInstructionMask")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttSetInstructionMask(GPUPerfAPI.GpaSessionId gpa_session_id, GPUPerfAPI.GpaSqttInstructionFlags sqtt_instruction_mask);
        
        /// <summary>
        /// @brief Gets the id of the compute unit which should generate the instruction level data.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sqtt_compute_unit_id">The value which will hold the compute unit id.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        /// All subsequent SQTT samples will use this compute unit id. Ignored if not collecting instruction-level information. Gpasession_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttGetComputeUnitId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttGetComputeUnitId(GPUPerfAPI.GpaSessionId gpa_session_id, out uint sqtt_compute_unit_id);
        
        /// <summary>
        /// @brief Sets the id of the compute unit which should generate the instruction level data.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sqtt_compute_unit_id">The new value to set the compute unit id to.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        /// All subsequent SQTT samples will use this compute unit id. Ignored if not collecting instruction-level information. gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttSetComputeUnitId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttSetComputeUnitId(GPUPerfAPI.GpaSessionId gpa_session_id, uint sqtt_compute_unit_id);
        
        /// <summary>
        /// Begin collecting Session SQTT data
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="command_list">the command list to begin collecting data</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttBegin")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttBegin(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list);
        
        /// <summary>
        /// End collecting SQTT data
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="command_list">the command list to end collection of data</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttEnd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttEnd(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list);
        
        /// <summary>
        /// Get SQTT sample result size
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_result_size_in_bytes">returns the number of bytes of data collected</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttGetSampleResultSize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, out nuint sample_result_size_in_bytes);
        
        /// <summary>
        /// Gets the SQTT sample results
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_result_size_in_bytes">size of the sqtt_results buffer</param>
        /// <param name="sqtt_results">buffer to return results in</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSqttGetSampleResult")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSqttGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, nuint sample_result_size_in_bytes, void* sqtt_results);
        
        /// <summary>
        /// [Optional] Sets the sample interval for SPM data. The default is 4096.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="interval">sampling interval in clock cycles of the GPU shader clock domain (SCLK). This ranges from [32 - 4096]</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmSetSampleInterval")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmSetSampleInterval(GPUPerfAPI.GpaSessionId gpa_session_id, uint interval);
        
        /// <summary>
        /// [Optional] Sets the duration of the SPM sample. The default is to assume that the sample is as large as possible.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="nanosecond_duration">duration in nanoseconds</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        /// If the duration is set, this allows the driver to optimize the amount of memory that is allocated for
        /// the SPM session. If the duration is not set, the recommended maximum amount of GPU memory will be
        /// allocated for SPM collection gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmSetDuration")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmSetDuration(GPUPerfAPI.GpaSessionId gpa_session_id, uint nanosecond_duration);
        
        /// <summary>
        /// Begin collecting SPM data
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="command_list">the command list to begin collecting data</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmBegin")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmBegin(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list);
        
        /// <summary>
        /// End collecting SPM data
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="command_list">the command list to end collecting data</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmEnd")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmEnd(GPUPerfAPI.GpaSessionId gpa_session_id, void* command_list);
        
        /// <summary>
        /// Get SPM sample result size
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_result_size_in_bytes">returns the number of bytes of data collected.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmGetSampleResultSize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, out nuint sample_result_size_in_bytes);
        
        /// <summary>
        /// Gets the SPM sample results
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_result_size_in_bytes">size of the spm_results buffer.</param>
        /// <param name="spm_results">buffer of returned results.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmGetSampleResult")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, nuint sample_result_size_in_bytes, void* spm_results);
        
        /// <summary>
        /// Calculate derived counters from collected SPM data
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="spm_data">Collected SPM data.</param>
        /// <param name="derived_counter_count">Number of counters that were enabled.</param>
        /// <param name="derived_counter_results">Counter results of num_derived_counters * timestamps entries.</param>
        /// <returns>@return The GPA result status of the operation. kGpaStatusOk is returned if the operation is successful.</returns>
        /// <remarks>
        ///  gpa_session_interrogation
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaSpmCalculateDerivedCounters")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaSpmCalculateDerivedCounters(GPUPerfAPI.GpaSessionId gpa_session_id, ref GPUPerfAPI.GpaSpmData spm_data, uint derived_counter_count, ulong* derived_counter_results);
        
        /// <summary>
        /// @brief Ends sampling with the currently enabled set of counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_session_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorOtherSessionActive A different session is currently active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNotEnoughPasses There have not been enough passes to complete the counter collection on this session.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorVariableNumberOfSamplesInPasses The number of samples in each pass was inconsistent.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEndSession")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEndSession(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Enables the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session on which to enable the counter.</param>
        /// <param name="counter_index">The index of the counter to enable. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will provide values for any enabled counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorAlreadyEnabled The specified counter is already enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEnableCounter")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEnableCounter(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index);
        
        /// <summary>
        /// @brief Disables the specified counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session on which to disable the counter.</param>
        /// <param name="counter_index">The index of the counter to disable. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will not provide values for any disabled counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange If the counter index is out of range.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNotEnabled The counter was not enabled, so it cannot be disabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaDisableCounter")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaDisableCounter(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index);
        
        /// <summary>
        /// @brief Enables the counter with the specified counter name (case insensitive).
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="counter_name">The name of the counter to enable.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will provide values for any enabled counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCounterNotFound The named counter cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorAlreadyEnabled The specified counter is already enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEnableCounterByName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEnableCounterByName(GPUPerfAPI.GpaSessionId gpa_session_id, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPUTF8Str)] string counter_name);
        
        /// <summary>
        /// @brief Disables the counter with the specified counter name (case insensitive).
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="counter_name">The name of the counter to disable.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will not provide values for any disabled counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCounterNotFound The named counter cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIncompatibleSampleTypes The specified counter is not compatible with the supplied session.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNotEnabled The counter could not be enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaDisableCounterByName")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaDisableCounterByName(GPUPerfAPI.GpaSessionId gpa_session_id, [global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPUTF8Str)] string counter_name);
        
        /// <summary>
        /// @brief Enables all counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will provide values for all counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to enable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEnableAllCounters")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEnableAllCounters(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Disables all counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// Subsequent sampling sessions will not provide values for any disabled counters.
        /// Initially all counters are disabled, and must explicitly be enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCannotChangeCountersWhenSampling It is invalid to disable a counter while the session is active.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaDisableAllCounters")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaDisableAllCounters(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Gets the number of passes required for the currently enabled set of counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="number_of_passes">The value which will hold the number of required passes upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This represents the number of times the same sequence must be repeated to capture the counter data.
        /// On each pass a different (compatible) set of counters will be measured. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetPassCount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetPassCount(GPUPerfAPI.GpaSessionId gpa_session_id, out uint number_of_passes);
        
        /// <summary>
        /// @brief Gets the number of enabled counters.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="enabled_counter_count">The value which will hold the number of enabled counters contained within the session upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        ///  gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetNumEnabledCounters")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetNumEnabledCounters(GPUPerfAPI.GpaSessionId gpa_session_id, out uint enabled_counter_count);
        
        /// <summary>
        /// @brief Gets the counter index for an enabled counter.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="enabled_number">The number of the enabled counter to get the counter index for. Must lie between 0 and (GpaGetNumEnabledCounters result - 1).</param>
        /// <param name="enabled_counter_index">The value that will hold the index of the counter upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This is meant to be used with GpaGetNumEnabledCounters. Once you determine the number of enabled counters,
        /// you can use GpaGetEnabledIndex to determine which counters are enabled. gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange The enabled number is higher than the number of enabled counters.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetEnabledIndex")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetEnabledIndex(GPUPerfAPI.GpaSessionId gpa_session_id, uint enabled_number, out uint enabled_counter_index);
        
        /// <summary>
        /// @brief Checks whether or not a counter is enabled.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the session.</param>
        /// <param name="counter_index">The index of the counter. Must lie between 0 and (GpaGetNumCounters result - 1).</param>
        /// <remarks>
        ///  gpa_counter_scheduling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk is returned if the counter is enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCounterNotFound is returned if it is not enabled.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If any of the parameters are NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorContextNotOpen The context on this session is not open.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaIsCounterEnabled")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaIsCounterEnabled(GPUPerfAPI.GpaSessionId gpa_session_id, uint counter_index);
        
        /// <summary>
        /// @brief Begins command list for sampling.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="pass_index">0-based index of the pass.</param>
        /// <param name="command_list">The command list on which to begin sampling - ignored in OpenGL/DX11 applications.</param>
        /// <param name="command_list_type">Command list type.</param>
        /// <param name="gpa_command_list_id">GPA-generated unique command list id.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// You will be unable to create samples on the specified command list before GpaBeginCommandList is called.
        /// Command list corresponds to ID3D12GraphicsCommandList in DirectX 12 and vkCommandBuffer in Vulkan.
        /// In OpenGL/DirectX 11, use GPA_NULL_COMMAND_LIST for the command_list parameter and kGpaCommandListNone for the command_list_type parameter. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If the command list is required, it must not be NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorInvalidParameter The command list type is invalid, or the command list must be null and the type must be kGpaCommandListNone.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListAlreadyStarted The supplied command list has already been started, and cannot be started again.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaBeginCommandList")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaBeginCommandList(GPUPerfAPI.GpaSessionId gpa_session_id, uint pass_index, void* command_list, GPUPerfAPI.GpaCommandListType command_list_type, out GPUPerfAPI.GpaCommandListId gpa_command_list_id);
        
        /// <summary>
        /// @brief Ends command list for sampling.
        /// </summary>
        /// <param name="gpa_command_list_id">The command list on which to end sampling - ignored in OpenGL applications.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// You will be unable to create samples on the specified command list after GpaEndCommandList is called. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEndCommandList")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEndCommandList(GPUPerfAPI.GpaCommandListId gpa_command_list_id);
        
        /// <summary>
        /// @brief Begins a sample in a command list.
        /// </summary>
        /// <param name="sample_id">Unique sample id.</param>
        /// <param name="gpa_command_list_id">Unique identifier of a previously-created GPA Command List Object.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// A sample is a particular workload for which counters will be collected.
        /// If the owning session was created with kGpaSessionSampleTypeDiscreteCounter and
        /// one or more counters have been enabled, then those counters will be collected for this sample.
        /// Each sample must be associated with a GPA command list.
        /// Samples can be created by multiple threads provided no two threads are creating samples on same command list.
        /// You must provide a unique Id for every new sample. When performing multiple passes, a sample must exist in all passes.
        /// You may create as many samples as needed. However, nesting of samples is not allowed.
        /// Each sample must be wrapped in sequence of GpaBeginSample/GpaEndSample before starting another one.
        /// A sample can be started in one primary command list and continued/ended on another primary command list - See GpaContinueSampleOnCommandList. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange The sample has been started in too many passes.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaBeginSample")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaBeginSample(uint sample_id, GPUPerfAPI.GpaCommandListId gpa_command_list_id);
        
        /// <summary>
        /// @brief Ends a sample in a command list.
        /// </summary>
        /// <param name="gpa_command_list_id">Command list id on which the sample is ending - the command list may be different than the command list on which the sample was started.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// A sample is a particular workload for which counters will be collected.
        /// If the owning session was created with kGpaSessionSampleTypeDiscreteCounter and
        /// one or more counters have been enabled, then those counters will be collected for this sample.
        /// Each sample must be associated with a GPA command list.
        /// Samples can be created by using multiple threads provided no two threads are creating samples on same command list.
        /// You must provide a unique Id for every new sample.
        /// You may create as many samples as needed. However, nesting of samples is not allowed.
        /// Each sample must be wrapped in sequence of GpaBeginSample/GpaEndSample before starting another one.
        /// A sample can be started in one primary command list and continued/ended on another primary command list - See GpaContinueSampleOnCommandList. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer If a NULL command list has been supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListNotFound If the supplied command list cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorIndexOutOfRange The sample has been ended in too many passes.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaEndSample")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaEndSample(GPUPerfAPI.GpaCommandListId gpa_command_list_id);
        
        /// <summary>
        /// @brief Continues a primary command list sample on another primary command list.
        /// </summary>
        /// <param name="source_sample_id">The sample id of the sample being continued on a different command list.</param>
        /// <param name="primary_gpa_command_list_id">Primary command list id on which the sample is continuing.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function is only supported for DirectX 12 and Vulkan.
        /// Samples can be started on one primary command list and continued/ended on another primary command list. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorApiNotSupported This entrypoint is being called in a graphics API that does not support it.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer The supplied command list id is NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListNotFound The supplied command list id cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSampleNotFound The source sample id cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaContinueSampleOnCommandList")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaContinueSampleOnCommandList(uint source_sample_id, GPUPerfAPI.GpaCommandListId primary_gpa_command_list_id);
        
        /// <summary>
        /// @brief Copies a set of samples from a secondary command list back to the primary command list that executed the secondary command list.
        /// </summary>
        /// <param name="secondary_gpa_command_list_id">Secondary command list where the secondary samples were created.</param>
        /// <param name="primary_gpa_command_list_id">Primary command list to which the samples results should be copied. This should be the command list that executed the secondary command list.</param>
        /// <param name="number_of_samples">Number of secondary samples.</param>
        /// <param name="new_sample_ids">New sample ids on a primary command list.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function is only supported for DirectX 12 and Vulkan.
        /// GPA doesn't collect data for the samples created on secondary command lists unless they are copied to a new set of samples for the primary command list. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorApiNotSupported This entrypoint is being called in a graphics API that does not support it.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer One of the supplied command list IDs is NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorCommandListNotFound One of the supplied command list IDs cannot be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaCopySecondarySamples")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaCopySecondarySamples(GPUPerfAPI.GpaCommandListId secondary_gpa_command_list_id, GPUPerfAPI.GpaCommandListId primary_gpa_command_list_id, uint number_of_samples, uint* new_sample_ids);
        
        /// <summary>
        /// @brief Gets the number of samples created for the specified session.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_count">The value which will hold the number of samples contained within the session upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This is useful if samples are conditionally created and a count is not kept. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer One of the parameters is NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetSampleCount")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetSampleCount(GPUPerfAPI.GpaSessionId gpa_session_id, out uint sample_count);
        
        /// <summary>
        /// @brief Gets the sample id by index.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="index">The index of the sample. Must lie between 0 and (GpaGetSampleCount result - 1).</param>
        /// <param name="sample_id">The value that will hold the id of the sample upon successful execution.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This is useful if sample ids are either not zero-based or not consecutive. gpa_sample_handling
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer One of the parameters is NULL.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSampleNotFound The supplied index is greater than the number of samples.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetSampleId")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetSampleId(GPUPerfAPI.GpaSessionId gpa_session_id, uint index, out uint sample_id);
        
        /// <summary>
        /// @brief Checks whether or not a pass has finished.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="pass_index">0-based index of the pass.</param>
        /// <remarks>
        /// After sampling a workload, results may be available immediately or take a certain amount of time to become available.
        /// This function allows you to determine when the pass has finished and associated resources are no longer needed in the application.
        /// The function does not block, permitting periodic polling.
        /// The application must not free its resources until this function returns kGpaStatusOk. gpa_query_results
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the pass is complete.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusResultNotReady If the result is not yet ready.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotStarted The supplied session has not been started.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaIsPassComplete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaIsPassComplete(GPUPerfAPI.GpaSessionId gpa_session_id, uint pass_index);
        
        /// <summary>
        /// @brief Checks if results for all samples within a session are available.
        /// </summary>
        /// <param name="gpa_session_id">The value that will be set to the session identifier.</param>
        /// <remarks>
        /// After a sampling session results may be available immediately or take a certain amount of time to become available.
        /// This function allows you to determine when the results of a session can be read.
        /// The function does not block, permitting periodic polling.
        /// To block until a sample is ready use GpaGetSampleResult instead. gpa_query_results
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the session is complete.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusResultNotReady If the result is not yet ready.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotStarted If the supplied session has not been started.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotEnded The session has not been ended.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaIsSessionComplete")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaIsSessionComplete(GPUPerfAPI.GpaSessionId gpa_session_id);
        
        /// <summary>
        /// @brief Gets the result size (in bytes) for a given sample.
        /// </summary>
        /// <param name="gpa_session_id">Unique identifier of the GPA Session Object.</param>
        /// <param name="sample_id">The identifier of the sample to get the result size for.</param>
        /// <param name="sample_result_size_in_bytes">The value that will be set to the result size upon successful execution  - this value needs to be passed to GetSampleResult.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// For discrete counter samples, the size will be the same for all samples, so it would be valid to retrieve the
        /// result size for one sample and use that when retrieving results for all samples. gpa_query_results
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer An invalid session was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSampleNotFound The supplied sample id could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetSampleResultSize")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetSampleResultSize(GPUPerfAPI.GpaSessionId gpa_session_id, uint sample_id, out nuint sample_result_size_in_bytes);
        
        /// <summary>
        /// @brief Gets the result data for a given sample.
        /// </summary>
        /// <param name="gpa_session_id">The session identifier with the sample you wish to retrieve the result of.</param>
        /// <param name="sample_id">The identifier of the sample to get the result for.</param>
        /// <param name="sample_result_size_in_bytes">Size of sample in bytes.</param>
        /// <param name="counter_sample_results">Address to which the counter data for the sample will be copied to.</param>
        /// <returns>@return The GPA result status of the operation.</returns>
        /// <remarks>
        /// This function will block until results are ready. Use GpaIsSessionComplete to check if results are ready. gpa_query_results
        /// </remarks>
        /// <retval>
        /// @retval kGpaStatusOk If the operation is successful.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorNullPointer An invalid or NULL parameter was supplied.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSessionNotFound The supplied session could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorSampleNotFound The supplied sample id could not be found.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorReadingSampleResult The supplied buffer is too small for the sample results.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorFailed If an internal error has occurred.
        /// </retval>
        /// <retval>
        /// @retval kGpaStatusErrorException If an unexpected error has occurred.
        /// </retval>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetSampleResult")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        public static partial GPUPerfAPI.GpaStatus GpaGetSampleResult(GPUPerfAPI.GpaSessionId gpa_session_id, uint sample_id, nuint sample_result_size_in_bytes, void* counter_sample_results);
        
        /// <summary>
        /// @brief Gets a string representation of the specified GPA status value.
        /// </summary>
        /// <param name="status">The status whose string representation is needed.</param>
        /// <returns>@return A string which briefly describes the specified status.</returns>
        /// <remarks>
        /// Provides a simple method to convert a status enum value into a string which can be used to display log messages. gpa_status_query
        /// </remarks>
        [global::System.Runtime.InteropServices.LibraryImport(LibraryName, EntryPoint = "GpaGetStatusAsStr")]
        [UnmanagedCallConv(CallConvs = new Type[] { typeof(CallConvCdecl) })]
        [return:global::System.Runtime.InteropServices.MarshalAs(UnmanagedType.LPUTF8Str)]
        public static partial string GpaGetStatusAsStr(GPUPerfAPI.GpaStatus status);
    }
}
