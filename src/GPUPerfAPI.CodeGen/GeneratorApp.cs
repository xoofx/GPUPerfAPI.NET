// Copyright (c) Alexandre Mutel. All rights reserved.
// Licensed under the BSD-Clause 2 license.
// See license.txt file in the project root for full license information.

using CppAst;
using CppAst.CodeGen.Common;
using CppAst.CodeGen.CSharp;
using Zio.FileSystems;

namespace GPUPerfAPI.CodeGen;

/// <summary>
/// Base class for a code generator using the CppAst and CppAst.CodeGen library.
/// </summary>
public class GeneratorApp
{
    public GeneratorApp()
    {
        RepositoryRootFolder = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, $@"..", "..", "..", "..", "..", ".."));

        // This is a protection to make sure that we are in the right folder
        var srcFolder = Path.Combine(RepositoryRootFolder, "src");
        if (!Directory.Exists(srcFolder) || !File.Exists(Path.Combine(srcFolder, "GPUPerfAPI.sln")))
        {
            throw new DirectoryNotFoundException($"The source folder `{srcFolder}` doesn't exist");
        }

        LibraryFolder = srcFolder;
        GeneratedFolder = Path.Combine(LibraryFolder, $"GPUPerfAPI", "generated");

        SourceSdkFolder = Path.Combine(RepositoryRootFolder, "tmp", GPUPerfAPIZipDownloader.NameAndVersion);
        ApiInclude = Path.Combine(SourceSdkFolder, "4_0", "include");
    }

    public string RepositoryRootFolder { get; }

    public string SourceSdkFolder { get; set; }

    public string ApiInclude { get; }

    public string LibraryFolder { get; }

    public string GeneratedFolder { get; }
    
    public virtual async Task Initialize()
    {
        if (!Directory.Exists(LibraryFolder))
        {
            Directory.CreateDirectory(LibraryFolder);
        }

        if (!Directory.Exists(GeneratedFolder))
        {
            Directory.CreateDirectory(GeneratedFolder);
        }

        if (!Directory.Exists(SourceSdkFolder))
        {
            Directory.CreateDirectory(SourceSdkFolder);
            Console.WriteLine($"Downloading SDK to {SourceSdkFolder}...");
            var downloader = new GPUPerfAPIZipDownloader();
            await downloader.DownloadAndExtractZipToFolder(SourceSdkFolder);
        }
    }

    public void Run()
    {
        var csCompilation = Generate();
        
        var fs = new PhysicalFileSystem();
        {
            var subfs = new SubFileSystem(fs, fs.ConvertPathFromInternal(GeneratedFolder));
            var codeWriter = new CodeWriter(new CodeWriterOptions(subfs)
            {
                Header = """
                         // Copyright (c) Alexandre Mutel. All rights reserved.
                         // Licensed under the BSD-Clause 2 license.
                         // See license.txt file in the project root for full license information.
                         //
                         // This file was automatically generated by GPUPerfAPI.CodeGen - DO NOT EDIT
                         """
            });
            csCompilation.DumpTo(codeWriter);
        }
    }

    public CSharpCompilation Generate()
    {

        List<string> srcFolders =
        [
            ApiInclude,
        ];

        var csOptions = new CSharpConverterOptions()
        {
            DefaultClassLib = "GPUPerfAPI",
            DefaultNamespace = "GPUPerfAPI",
            DefaultOutputFilePath = "/GPUPerfAPI.generated.cs",
            DefaultDllImportNameAndArguments = "LibraryName",
            Defines =
            {
            },
            PreHeaderText = @"",
            DispatchOutputPerInclude = true,
            DisableRuntimeMarshalling = true,
            AllowMarshalForString = true,
            //TypedefNoWrapForceList =
            //{
            //    "GpaFunctionTable"
            //},
            MappingRules =
            {
                e => e.MapMacroToConst("GPA_FUNCTION_TABLE_MAJOR_VERSION_NUMBER", "int"),
                e => e.MapMacroToConst("GPA_FUNCTION_TABLE_MINOR_VERSION_NUMBER", "int"),

                e => e.MapType("HMODULE", "nint"),
                e => e.MapType("GUID", "System.Guid"),
                e => e.MapType("GpaUInt8", "byte"),
                e => e.MapType("GpaUInt16", "ushort"),
                e => e.MapType("GpaUInt32", "uint"),
                e => e.MapType("GpaUInt64", "ulong"),
                e => e.MapType("GpaFloat32", "float"),
                e => e.MapType("GpaFloat64", "double"),
                e => e.MapType("_GpaSessionId *", "nint"),
                e => e.MapType("_GpaContextId *", "nint"),
                e => e.MapType("_GpaCommandListId *", "nint"),
                e => e.Map("_GpaSessionId").Discard(),
                e => e.Map("_GpaContextId").Discard(),
                e => e.Map("_GpaCommandListId").Discard(),
                e => e.Map("LibHandle").Discard(),
                e => e.Map("GpaFlags").Discard(),

                e => e.Map<CppParameter>("GpaGetVersion::major_version").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetVersion::minor_version").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetVersion::build_version").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetVersion::update_version").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetFuncTable::gpa_func_table").Type("GpaFunctionTable*").ByRef(CSharpRefKind.Ref), // Special case, as it requires to fill version
                e => e.Map<CppParameter>("GpaOpenContext::gpa_context_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetSupportedSampleTypes::sample_types").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetDeviceAndRevisionId::device_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetDeviceAndRevisionId::revision_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetDeviceName::device_name").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetDeviceGeneration::hardware_generation").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetNumCounters::number_of_counters").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterName::counter_name").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterIndex::counter_index").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterGroup::counter_group").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterDescription::counter_description").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterDataType::counter_data_type").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterUsageType::counter_usage_type").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterUuid::counter_uuid").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetCounterSampleType::counter_sample_type").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetDataTypeAsStr::type_as_str").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetUsageTypeAsStr::usage_type_as_str").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaCreateSession::gpa_session_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaSqttGetInstructionMask::sqtt_instruction_mask").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaSqttGetComputeUnitId::sqtt_compute_unit_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaSqttGetSampleResultSize::sample_result_size_in_bytes").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaSpmGetSampleResultSize::sample_result_size_in_bytes").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetPassCount::number_of_passes").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetNumEnabledCounters::enabled_counter_count").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetEnabledIndex::enabled_counter_index").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaBeginCommandList::gpa_command_list_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetSampleCount::sample_count").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetSampleId::sample_id").ByRef(CSharpRefKind.Out),
                e => e.Map<CppParameter>("GpaGetSampleResultSize::sample_result_size_in_bytes").ByRef(CSharpRefKind.Out),


                e => e.Map<CppParameter>("GpaOpenContext::gpa_context_id").ByRef(CSharpRefKind.Out),
            },
        };

        foreach (var srcFolder in srcFolders)
        {
            csOptions.IncludeFolders.Add(srcFolder);
        }

        var files = new List<string>()
        {
            Path.Combine(ApiInclude, Path.Combine("gpu_performance_api", "gpu_perf_api.h")),
        };

        csOptions.Plugins.Add(new CSharpConverterGpaFlags());

        Console.WriteLine("Generating C# binding code...");
        var csCompilation = CSharpConverter.Convert(files, csOptions);

        {
            foreach (var message in csCompilation.Diagnostics.Messages)
            {
                if (message.Type == CppLogMessageType.Error)
                {
                    Console.Error.WriteLine(message);
                }
            }

            if (csCompilation.HasErrors)
            {
                Console.Error.WriteLine("Unexpected parsing errors");
                Environment.Exit(1);
            }
        }

        PatchFunctionTable(csCompilation);

        Console.WriteLine($"Code successfully generated to {GeneratedFolder}");
        
        return csCompilation;
    }

    // This function is used to patch the function table, replicate the documentation from functions to function pointers
    // and add marshalling for string parameters/return types.
    private void PatchFunctionTable(CSharpCompilation csCompilation)
    {
        var gpaFunctionTable = csCompilation.AllStructs.First(x => x.Name == "GpaFunctionTable");

        foreach (var function in csCompilation.AllFunctions)
        {
            var csField = gpaFunctionTable.Members.OfType<CSharpField>().FirstOrDefault(x => x.Name == function.Name);

            if (csField is null) continue;


            var method = function.Clone();
            csField.Name = $"_{csField.Name}";
            method.Attributes.Clear();
            method.Modifiers = CSharpModifiers.Unsafe;
            gpaFunctionTable.Members.Insert(gpaFunctionTable.Members.IndexOf(csField) + 1, method);

            bool returnString = false;
            // String return
            if (method.ReturnType is CSharpTypeWithAttributes returnTypeWithAttributes)
            {
                method.ReturnType = returnTypeWithAttributes.ElementType;
                returnString = true;
            }

            var stringParameters = new List<int>();

            // String marshalling
            for (var i = 0; i < method.Parameters.Count; i++)
            {
                var parameter = method.Parameters[i];
                if (parameter.ParameterType is CSharpTypeWithAttributes typeWithAttributes)
                {
                    parameter.ParameterType = typeWithAttributes.ElementType;
                    if (parameter.ParameterType is CSharpPrimitiveType primitiveType && primitiveType.Kind == CSharpPrimitiveKind.String)
                    {
                        stringParameters.Add(i);
                    }
                }
            }

            method.Body = (writer, _) =>
            {
                bool noReturn = method.ReturnType is CSharpPrimitiveType primitive && primitive.Kind == CSharpPrimitiveKind.Void;

                // String marshalling
                for (var i = 0; i < method.Parameters.Count; i++)
                {
                    var parameter = method.Parameters[i];
                    if (stringParameters.Contains(i))
                    {
                        writer.WriteLine($"System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn {parameter.Name}_marshal = new();");
                        writer.WriteLine($"Span<byte> {parameter.Name}_buffer = stackalloc byte[System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller.ManagedToUnmanagedIn.BufferSize];");
                    }
                }

                if (stringParameters.Count > 0)
                {
                    writer.WriteLine("try");
                    writer.OpenBraceBlock();

                    foreach (var i in stringParameters)
                    {
                        var parameter = method.Parameters[i];
                        // counter_name_marshal.FromManaged(counter_name, counter_name_buffer);
                        writer.WriteLine($"{parameter.Name}_marshal.FromManaged({parameter.Name}, {parameter.Name}_buffer);");
                    }
                }

                for (var i = 0; i < method.Parameters.Count; i++)
                {
                    var parameter = method.Parameters[i];
                    if (parameter.ParameterType is CSharpRefType refType)
                    {
                        writer.Write($"fixed (");
                        refType.ElementType.DumpReferenceTo(writer);
                        writer.WriteLine($"* {parameter.Name}_ptr = &{parameter.Name})");
                    }
                }

                if (!noReturn)
                {
                    writer.Write("return ");
                    if (returnString)
                    {
                        writer.Write("System.Runtime.InteropServices.Marshal.PtrToStringUTF8((nint)");
                    }
                }
                writer.Write(csField.Name);
                writer.Write(".Value(");
                for (var i = 0; i < method.Parameters.Count; i++)
                {
                    var parameter = method.Parameters[i];
                    if (i > 0)
                    {
                        writer.Write(", ");
                    }

                    writer.Write(stringParameters.Contains(i) ? $"{parameter.Name}_marshal.ToUnmanaged()" : parameter.ParameterType is CSharpRefType ? $"{parameter.Name}_ptr" : parameter.Name);
                }

                writer.WriteLine(returnString ? "));" : ");");

                if (stringParameters.Count > 0)
                {
                    writer.CloseBraceBlock();
                    writer.WriteLine("finally");
                    writer.OpenBraceBlock();

                    foreach (var i in stringParameters)
                    {
                        var parameter = method.Parameters[i];
                        writer.WriteLine($"{parameter.Name}_marshal.Free();");
                    }
                    writer.CloseBraceBlock();
                }

            };
        }
    }

    private class CSharpConverterGpaFlags : ICSharpConverterPlugin
    {
        private readonly Dictionary<string, CSharpEnum> _flags = new();

        public void Register(CSharpConverter converter, CSharpConverterPipeline pipeline)
        {
            pipeline.Converted.Add(ProcessConverted);
            pipeline.TypedefConverters.Add(ProcessTypeDef);
        }

        private void ProcessConverted(CSharpConverter converter, CSharpElement element, CSharpElement context)
        {
            if (element is CSharpEnum cSharpEnum && cSharpEnum.Name.Contains("Bits"))
            {
                cSharpEnum.IsFlags = true;
                cSharpEnum.Name = cSharpEnum.Name.Replace("Bits", "Flags", StringComparison.Ordinal);
                _flags.Add(cSharpEnum.Name, cSharpEnum);
            }
        }

        private CSharpElement? ProcessTypeDef(CSharpConverter converter, CppTypedef cpptypedef, CSharpElement context)
        {
            if (cpptypedef.Name.Contains("Flags"))
            {
                if (_flags.TryGetValue(cpptypedef.Name, out var csEnum))
                {
                    return csEnum;
                }
            }
            return null;
        }
    }
}